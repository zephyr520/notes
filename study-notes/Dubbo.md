## Dubbo ##

## 架构 ##
![](images/dubbo-architecture.jpg)

#### **节点角色说明**
|    节点   |  角色说明 |
| ----------| ------------- |
| Provider  | 暴露服务的服务提供方  |
| Consumer  | 调用远程服务的服务消费方  |
| Registry  | 服务注册与发现的注册中心  |
| Monitor   | 统计服务的调用次数和调用时间的监控中心  |
| Container | 服务运行容器  |

#### **调用关系说明**
1. 服务容器负责启动，加载，运行服务提供者
2. 服务提供者在启动时，向注册中心注册自己提供的服务
3. 服务消费者在启动时，向注册中心订阅自己所需的服务
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心

**Dubbo架构具有以下特点：**连通性、健壮性、伸缩性、以及向未来架构的升级性

#### **连通性**
1. 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小
2. 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示
3. 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销
4. 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销
5. 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外
6. 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者
7. 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表
8. 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者

#### **健状性**
1. 监控中心宕掉不影响使用，只是丢失部分采样数据
2. 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
3. 注册中心对等集群，任意一台宕掉后，将自动切换到另一台
4. 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯
5. 服务提供者无状态，任意一台宕掉后，不影响使用
6. 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复

#### **伸缩性**
1. 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心
2. 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者

#### **升级性**
当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：

![](images/dubbo-architecture-future.jpg)

**节点角色说明**

|    节点   |  角色说明 |
| ----------| ------------- |
| Deployer  | 自动部署服务的本地代理  |
| Repository  | 仓库用于存储服务应用发布包  |
| Scheduler  | 调度中心基于访问压力自动增减服务提供者  |
| Admin | 统一管理控制台  |
| Registry  | 服务注册与发现的注册中心  |
| Monitor   | 统计服务的调用次数和调用时间的监控中心  |

## 集群容错 ## 
在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。
![](images/cluster.jpg)

**各节点关系：**
- 这里的Invoker是Provider的一个可调用Service的抽象，Invoker封装了Provider地址及Service接口信息
- Directory代表多个Invoker，可以把它看成List<Invoker> ，但与List不同的是，它的值可能是动态变化的，比如注册中心推送变更
- Cluster将Directory中的多个Invoker伪装成一个Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个
- Router负责从多个Invoker中按路由规则选出子集，比如读写分离，应用隔离等
- LoadBalance负责从多个Invoker中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选

#### **集群容错模式**

- **Failover Cluster**
> 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries="2" 来设置重试次数(不含第一次)。

- **Failfast Cluster**
> 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。

- **Failsafe Cluster**
> 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。

- **Failback Cluster**
> 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。

- **Forking Cluster**
> 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。

- **Broadcast Cluster**
> 广播调用所有提供者，逐个调用，任意一台报错则报错 2。通常用于通知所有提供者更新缓存或日志等本地资源信息。

## 负载均衡 ##
> 在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。

#### **负载均衡策略**

- **Random LoadBalance**
	- **随机**，按权重设置随机概率。
	- 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

- **RoundRobin LoadBalance**
	- **轮循**，按公约后的权重设置轮循比率。
	- 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

- **LeastActive LoadBalance**
	- **最少活跃调用数**，相同活跃数的随机，活跃数指调用前后计数差
	- 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

- **ConsistentHash LoadBalance**
	- **一致性 Hash**，相同参数的请求总是发到同一提供者
	- 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。
	- 算法参见：[http://en.wikipedia.org/wiki/Consistent_hashing](http://en.wikipedia.org/wiki/Consistent_hashing)
	- 缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key="hash.arguments" value="0,1" />
	- 缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key="hash.nodes" value="320" />